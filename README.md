# MyCpu
Проект исполнителя собственного языка машинных команд. Состоит из трёх программ: ассемблер, дизассемблер и процессор. Они используют одну и ту же версию языка.

# Особенности языка
Язык состоит из машинных команд без операндов или одним операндом. Имеется внутренняя оперативная память, регистры и стек.
Команды последней версии языка задаются в файле `src/commands.h`, а имена в коде и состав их аргументов в `src/command.c`. 

В коде поддерживаются 3 типа аргументов:
* IMM - знаковая целочисленная константа от -2^31 до 2^31-1.
* REG - регистр. Количество регистров задаётся в файле `src/config.c`. Изначально их 4: ax, bx, cx, dx. Регистры от 5-го и далее имеют аналогичны буквы.
* MEM - ячейка в оперативной памяти. Имеет вид [\<reg\> + \<imm\>]. Где \<reg\> - регистр, \<imm\> - константа. Размер оперативной памяти в байтах задаётся в `src/config.c`.
* LABEL - метка, устанавливаемая в коде. В коде записывается как `<label>:` в отдельной строке. Как аргумент используется только имя без двоеточия.
Для задания наличия и типа аргумента в `src/command.c` есть массив `COMMAND_CODE`. В нём для каждой команды находится её код для бинарного файла. 

Первые 5 бит кода команды - её номер по порядку. 
* Шестой бит - флаг, можно ли в качестве аргумента использовать константу. 
* Седьмой бит - можно ли использовать регистр. 
* Восьмой - можно ли использовать путь в оперативной памяти.

В последней версии языка имеются 19 комманд.
### 0. HLT
Конец программы.
### 1. PUSH \<IMM\> | \<REG\> | \<MEM\>
Помещает значение из аргумента в стек.
### 2. POP \<REG\> | \<MEM\>
Получает верхнее значение из стека и помещает в аргумент.
### 3. IN
Получает число типа IMM из `stdin` и помещает в стек.
### 4. ADD
Берёт из стека 2 элемента и кладёт в него их сумму.
### 5. SUB
Берёт из стека сначала B, затем A, и кладёт в него число (A-B).
### 6. MUL
Берёт из стека 2 элемента и кладёт в него их произведение.
### 7. DEL
Берёт из стека сначала B, затем A, и кладёт в него число (A/B) - целочисленное деление.
### 8. DUPE
Берёт из стека значение, а затем кладёт его в стек дважды.
### 9. OUT
Берёт значение из стека и выводит его, как целое число в `stdout`.
### 10. JMP \<LABEL\>
Безусловный переход на позицию по аргументу.
### 11-16. JE, JNE, JL, JLE, JG, JGE \<LABEL\>
Это условные переходы. Каждая из команд принимает один аргумент - имя метки \<LABEL\>.
Затем получает из стека два элемента. Сначала B, затем A, и сравнивает их. Если в названии команды есть символ 'E', то при `A==B` произойдёт переход.
Если есть 'L', то при `A < B` тоже произойдёт переход. Если есть 'G', то переход также произойдёт при `A > B`.
### 17. CALL \<LABEL\>
Переходит на позицию по аргументу LABEL, положив в стек позицию, в которой была произведена команда.
### 18. RET
Переходит на позицию, полученную из верхнего элемента стека.

-----

Комментарий оформляется, начиная с символа `;`, затем может идти любой текст до конца строки. Он не будет участвовать в создании кода.

Вот пример программы на этом языке. Это алгоритм поиска НОД двух чисел:
```asm
JMP ~gcd ; work with 2 arguments
gcd: 
	POP bx
	POP ax

	gcd_while:
	PUSH 0
	PUSH bx

	JGE gcd_ret

		PUSH ax
		PUSH ax
		PUSH bx
		DEL
		PUSH bx
		MUL
		SUB

		PUSH bx
		POP ax

		POP bx

		JMP gcd_while
  	gcd_ret:
  	PUSH ax
  	RET
~gcd:

IN ; a
IN ; b

CALL gcd
OUT
HLT
```

Другие примеры использования команд вы можете посмотреть в папке `bin` в файлах с примерами:
* Нахождение НОД. Вводятся 2 числа типа IMM. Выводится их НОД. [gcd.txt](https://github.com/KIrillPal/MyCpu/blob/main/bin/gcd.txt)
* Выводит числа от 1 до 9. [myprog.txt](https://github.com/KIrillPal/MyCpu/blob/main/bin/myprog2.txt)
* Решение произвольных квадратных уравнений. Сначала вводится число 10^d, где d - нужное количество чисел после запятой.
При выведении корни будут умножены на 10^d. Затем воодятся 3 любых числа A,B и C - коэффициенты уравнения.
Программа выводит количество корней - 0, 1 или 2 по их количеству, либо -1, если корень - любое число.
Затем выводятся 2 числа - найденные корни. Есл корень не найден, вместо него выведется число -1. [solve_squares.txt](https://github.com/KIrillPal/MyCpu/blob/main/bin/solve_squares.txt)
# Формат бинарного файла.
Бинарный файл программы начиснается с 4 символов - сигнатуры. Она задаётся в файле `src/config.c`. Сейчас используется сигнатура 'EASY'. Затем идёт версия кода, затем длина кода. Затем идут сами команды. Файл всегда заканчивается командой 0 - т.е. завершением программы. 

Еть 2 режима ассемблирования. Он указывается в файле `src/config.c` флагом `MEM_FRIENDLY`. Если `MEM_FRIENDLY = 1`, то программа кодируется неравномерно, т.е. команда без аргументов занимает 1 байт, а команда с аргументом - 1 + `CELL_SIZE` байт. По умолчанию это 5 байт. При этом перед запуском программы в `run` файл расширяется до равномерной записи, что тратит немного больше времени, чем при равномерном кодировании. Если же MEM_FRIENDLY = 0, то происходит равномерное кодирование, и файл исполняется сразу без предобработки, однако занимает кратно больше памяти.
# Структура проекта
В папке `src` находится реализация трёх основных программ и программы make.
## 1. Assembler
Находится в папке `src/assemble` и реализован в файле `assemble.c`. Получает на вход текст программы в стандартный ввод, т.е. в `stdin`. Выводит в `stdout` бинарный файл побайтово. В случае ошибки выводит причину в `stderr`.

Скомпилированную программу можно запускать `./assemble < program.txt > program.bin`. Также возможно указать имена файлов в качестве аргументов, т.е. допустим вызов `./assemble program.txt program.bin`
Для хранения меток label используется бор. Его реализация в файлах `name_table.c` и `name_table.h`. Для получения текста программы целиком используется библиотека `text.h`, сделанная ранее. 
## 2. Disassembler
Находится в папке `src/disassemble` и реализован в файле `disassemble.c`. Получает на вход бинарный файл программы в стандартный ввод побайтово, т.е. в `stdin`. Выводит в `stdout` текст дизассемблированной программы.  
В случае ошибки выводит причину в `stderr`.

Скомпилированную программу можно запускать `./disassemble < program.bin > program.txt`. Также возможно указать имена файлов в качестве аргументов, т.е. допустим вызов `./disassemble program.bin program.txt`.  
## 3. Run 
Находится в папке `src/run` и реализован в файле `run.c`. Получает в качестве аргумента имя бинаного файла и исполняет его. 
 В случае ошибки выводит причину в `stderr`.
## 4. Make
Находится в папке `make` и реализован в файлах `make.c` и `wmake.c` - для linux и windows соответственно. В файлах реализована программа сборки для всех трёх программ с проверкой изменения файлов. Запуск для linux осуществляется `./make`. Также можно запустить make с аргументом в в виде имени файла с кодом. 
Т.е. если запустить `./make program.txt` относительно папки `make`, тогда он скомпилирует программы `bin/assemble`, `bin/disasseble` и `bin/run`, 
а затем последовательно проассмеблирует код из program.txt в файл `bin/pogram.bin`, затем выполнит файл `bin/program.bin`.

Для работы make необходимо наличие компилятора g++.

## 5. config.h и config.c
Здесь задаются основные настройки языка и исполнения. В конфиге устанавливаются следующие значения:
1. SIGNATURE     - сигнатура исполняемого файла.
2. VERSION       - версия языка, с которым работают assembler, disassembler и run.
3. MAX_CODE_SIZE - максимальное количество символов в файле исходного кода.
4. MEM_FRIENDLY  - флаг, указывающий на способ сжатия исполняемого файла. 
Если MEM_FRIENDLY = 1, то программа кодируется неравномерно. Иначе MEM_FRIENDLY = 0.
5. CELL_SIZE     - количество байтов, отводимое на тип IMM. Вместе с изменением CELL_SIZE изменяется и диапазон чисел IMM. 
Допустимо `CELL_SIZE = 2, 4, 8`.
6. CELL_FORMAT       - формат, используемый для вывода типа IMM.
7. REGISTER_NUMBER   - количество используемых в языке регистров. Например, если `REGISTER_NUMBER = 7`, то допустимы регистры ax, bx, cx, dx, ex, fx, gx.
8. SOFT_RAM_SIZE - размер виртуальной оперативной памяти в байтах, используемой для исполнения. Содержит SOFT_RAM_SIZE / CELL_SIZE ячеек чисел IMM. 

-----

# Использование проекта
Для linux:
Чтобы использовать проект, скачайте архив проекта и распакуйте в папке. Затем перейдите к папке `make` и в ней скомпилируйте `g++ make.c -o make`. Теперь выберите файл с кодом программы и запустите make, указав аргументом путь относительно папки make. Например, для программы gcd это `./make ../bin/gcd.txt`
Теперь в консоли запущена программа gcd.
